<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>YM</title>
<style>
  :root {
    --bg: #0b1220;
    --panel: #0f172a;
    --accent: #6366f1;
    --muted: #94a3b8;
  }
  html, body {
    height: 100%;
    margin: 0;
    background: var(--bg);
    color: #e6eef8;
    font-family: "Inter", system-ui, Arial;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  header {
    text-align: center;
    padding: 12px 8px;
    background: var(--panel);
    font-size: 18px;
    font-weight: bold;
    letter-spacing: 0.5px;
  }
  #controls {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    background: var(--panel);
    gap: 10px;
    padding: 10px;
    position: sticky;
    top: 0;
    z-index: 5;
  }
  button {
    background: var(--accent);
    border: none;
    color: white;
    font-size: 15px;
    border-radius: 10px;
    padding: 10px 16px;
    flex: 1 1 30%;
    min-width: 90px;
    max-width: 140px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.25);
    transition: 0.15s;
  }
  button:active {
    transform: scale(0.96);
    opacity: 0.85;
  }
  button.ghost {
    background: #1e293b;
    border: 1px solid #334155;
  }
  #wrap {
    flex: 1;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  canvas {
    width: 96vw;
    height: 70vh;
    background: #0f172a;
    touch-action: none;
    border-radius: 10px;
    box-shadow: 0 4px 25px rgba(0,0,0,0.6);
    border: 2px solid #334155;
  }
  footer {
    text-align: center;
    font-size: 13px;
    color: var(--muted);
    padding: 8px;
    background: var(--panel);
  }
  @media (max-width: 600px) {
    button {
      font-size: 14px;
      padding: 8px 12px;
      min-width: 70px;
    }
    header {
      font-size: 16px;
    }
    footer {
      font-size: 12px;
    }
    canvas {
      width: 98vw;
      height: 65vh;
    }
  }
</style>
</head>
<body>
<header>YM â€” Knightâ€™s Tour</header>

<div id="controls">
  <button id="nextBtn">Next</button>
  <button id="undoBtn" class="ghost">Undo</button>
  <button id="resetBtn" class="ghost">Reset</button>
</div>

<div id="wrap">
  <canvas id="board"></canvas>
</div>

<footer>ðŸ“± Tap any cell to start â€¢ Valid knight moves only â€¢ Pinch to zoom â€¢ Drag to pan</footer>

<script>
const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");
const nextBtn = document.getElementById("nextBtn");
const undoBtn = document.getElementById("undoBtn");
const resetBtn = document.getElementById("resetBtn");

let N = 200;
let cellSize = 20;
canvas.width = window.innerWidth * 0.9;
canvas.height = window.innerHeight * 0.7;

let visited = Array.from({length: N}, () => Array(N).fill(0));
let path = [];
let started = false;
let scale = 1;
let originX = 0, originY = 0;
let isDragging = false, dragStart = {x: 0, y: 0};

const moves = [
  [2, 1], [1, 2], [-1, 2], [-2, 1],
  [-2, -1], [-1, -2], [1, -2], [2, -1]
];

function nextMove(x, y) {
  let bestMove = null, minDeg = 9;
  for (let [dx, dy] of moves) {
    let nx = x + dx, ny = y + dy;
    if (nx >= 0 && ny >= 0 && nx < N && ny < N && !visited[ny][nx]) {
      let count = 0;
      for (let [mx, my] of moves) {
        let tx = nx + mx, ty = ny + my;
        if (tx >= 0 && ty >= 0 && tx < N && ty < N && !visited[ty][tx]) count++;
      }
      if (count < minDeg) {
        minDeg = count;
        bestMove = [nx, ny];
      }
    }
  }
  return bestMove;
}

function drawBoard() {
  ctx.setTransform(scale, 0, 0, scale, originX, originY);
  ctx.clearRect(-originX/scale, -originY/scale, canvas.width/scale, canvas.height/scale);

  ctx.strokeStyle = "#ddd";
  ctx.lineWidth = 0.5 / scale;
  for (let i = 0; i <= N; i++) {
    ctx.beginPath();
    ctx.moveTo(0, i * cellSize);
    ctx.lineTo(N * cellSize, i * cellSize);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(i * cellSize, 0);
    ctx.lineTo(i * cellSize, N * cellSize);
    ctx.stroke();
  }

  // path line
  ctx.strokeStyle = "lime";
  ctx.lineWidth = 2 / scale;
  ctx.beginPath();
  for (let i = 0; i < path.length - 1; i++) {
    const [x1, y1] = path[i];
    const [x2, y2] = path[i + 1];
    ctx.moveTo(x1 * cellSize + cellSize/2, y1 * cellSize + cellSize/2);
    ctx.lineTo(x2 * cellSize + cellSize/2, y2 * cellSize + cellSize/2);
  }
  ctx.stroke();

  // visited squares + move numbers
  ctx.font = `${15 / scale}px Arial`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  for (let i = 0; i < path.length; i++) {
    const [x, y] = path[i];
    ctx.fillStyle = "#cde";
    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
    ctx.fillStyle = "#000";
    ctx.fillText(i + 1, x * cellSize + cellSize/2, y * cellSize + cellSize/2);
  }

  // highlight possible moves
  if (started && path.length) {
    const [cx, cy] = path[path.length - 1];
    ctx.fillStyle = "rgba(0,255,0,0.25)";
    for (let [dx, dy] of moves) {
      const nx = cx + dx, ny = cy + dy;
      if (nx >= 0 && ny >= 0 && nx < N && ny < N && !visited[ny][nx]) {
        ctx.fillRect(nx * cellSize, ny * cellSize, cellSize, cellSize);
      }
    }
  }
}

function nextStep() {
  if (!started || !path.length) return;
  const [x, y] = path[path.length - 1];
  const move = nextMove(x, y);
  if (!move) return;
  visited[move[1]][move[0]] = 1;
  path.push(move);
  drawBoard();
}

function undoStep() {
  if (!started || path.length <= 1) return;
  const [x, y] = path.pop();
  visited[y][x] = 0;
  drawBoard();
}

function resetBoard() {
  visited = Array.from({length: N}, () => Array(N).fill(0));
  path = [];
  started = false;
  drawBoard();
}

// ðŸŸ¢ User-click Start + Manual move
canvas.addEventListener("click", e => {
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left - originX) / (cellSize * scale));
  const y = Math.floor((e.clientY - rect.top - originY) / (cellSize * scale));
  if (x < 0 || y < 0 || x >= N || y >= N) return;

  if (!started) {
    started = true;
    visited[y][x] = 1;
    path = [[x, y]];
    drawBoard();
    return;
  }

  const [cx, cy] = path[path.length - 1];
  const isValid = moves.some(([dx, dy]) => cx + dx === x && cy + dy === y);
  if (isValid && !visited[y][x]) {
    visited[y][x] = 1;
    path.push([x, y]);
    drawBoard();
  }
});

// Zoom
canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const zoom = e.deltaY < 0 ? 1.1 : 0.9;
  const mouseX = (e.offsetX - originX) / scale;
  const mouseY = (e.offsetY - originY) / scale;
  scale *= zoom;
  originX = e.offsetX - mouseX * scale;
  originY = e.offsetY - mouseY * scale;
  drawBoard();
});

// Touch zoom
let lastDist = 0;
canvas.addEventListener("touchmove", e => {
  if (e.touches.length === 2) {
    e.preventDefault();
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (lastDist) {
      const zoom = dist / lastDist;
      const rect = canvas.getBoundingClientRect();
      const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
      const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;
      const mouseX = (cx - originX) / scale;
      const mouseY = (cy - originY) / scale;
      scale *= zoom;
      originX = cx - mouseX * scale;
      originY = cy - mouseY * scale;
      drawBoard();
    }
    lastDist = dist;
  }
});
canvas.addEventListener("touchend", () => lastDist = 0);

// Pan
canvas.addEventListener("pointerdown", e => {
  isDragging = true;
  dragStart.x = e.clientX - originX;
  dragStart.y = e.clientY - originY;
  canvas.style.cursor = "grabbing";
});
canvas.addEventListener("pointermove", e => {
  if (isDragging) {
    originX = e.clientX - dragStart.x;
    originY = e.clientY - dragStart.y;
    drawBoard();
  }
});
canvas.addEventListener("pointerup", () => {
  isDragging = false;
  canvas.style.cursor = "grab";
});

nextBtn.onclick = nextStep;
undoBtn.onclick = undoStep;
resetBtn.onclick = resetBoard;

drawBoard();
</script>
</body>
</html>
